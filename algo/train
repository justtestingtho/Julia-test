start_t = time()
using NeuralPDE, Flux, ModelingToolkit, GalacticOptim, Optim, DiffEqFlux
using Quadrature, Cuba, QuasiMonteCarlo, Printf, Plots, StructTypes, JSON3
using BSON: @save
import ModelingToolkit: Interval, infimum, supremum
@info "Time to compile: " time() - start_t
###Define a struct that defines the types of parameters in the JSON file
struct MyType
    First_layer::Int
    Second_layer::Int
    _tuning_objective_metric::String
end

##Boiler code for paths, don't change
StructTypes.StructType(::Type{MyType}) = StructTypes.Struct()
prefix = "/opt/ml/"
param_path = joinpath(prefix, "input/config/hyperparameters.json")
output_path = joinpath(prefix, "output")
model_path = joinpath(prefix, "model")

try
    #Loading parameters for model
    json_string = reduce(replace, ["\n" => "", "\t" => ""], init = read(param_path, String))
    test_params = JSON3.read(json_string, MyType; parsequoted=true)
    #Unpack parameters from JSON here
    n1 = test_params.First_layer
    n2 = test_params.Second_layer
    println("Defining model to be surrogatized by a NeuralPDE")
    #3D PDE
    model_def_t = time()
    @parameters t x y
    @variables u(..)
    Dxx = Differential(x)^2
    Dyy = Differential(y)^2
    Dt = Differential(t)
    t_min= 0.
    t_max = 2.0
    x_min = 0.
    x_max = 2.
    y_min = 0.
    y_max = 2.

    # 3D PDE
    eq  = Dt(u(t,x,y)) ~ Dxx(u(t,x,y)) + Dyy(u(t,x,y))

    analytic_sol_func(t,x,y) = exp(x+y)*cos(x+y+4t)
    # Initial and boundary conditions
    bcs = [u(t_min,x,y) ~ analytic_sol_func(t_min,x,y),
            u(t,x_min,y) ~ analytic_sol_func(t,x_min,y),
            u(t,x_max,y) ~ analytic_sol_func(t,x_max,y),
            u(t,x,y_min) ~ analytic_sol_func(t,x,y_min),
            u(t,x,y_max) ~ analytic_sol_func(t,x,y_max)]

    # Space and time domains
    domains = [t ∈ Interval(t_min,t_max),
                x ∈ Interval(x_min,x_max),
                y ∈ Interval(y_min,y_max)]

    # Neural network
    inner = 10
    println("Defining NeuralPDE")
    chain = FastChain(FastDense(3,n1,Flux.σ),
                  FastDense(n1,n2,Flux.σ),
                  FastDense(n2,inner,Flux.σ),
                  FastDense(inner,1))

    initθ = DiffEqFlux.initial_params(chain)

    strategy = NeuralPDE.QuasiRandomTraining(6000; #points
                                         sampling_alg = UniformSample(),
                                         minibatch = 100)
    discretization = NeuralPDE.PhysicsInformedNN(chain,
                                             strategy;
                                             init_params = initθ)
    phi = discretization.phi
    pde_system = PDESystem(eq,bcs,domains,[t,x,y],[u])
    prob = NeuralPDE.discretize(pde_system,discretization)
    maxiters = 5
    cb = function (p,l)
        println("train_loss=$l;")
        return false
    end
    @info "Time to define model: " time()-model_def_t
    println("Started training")
    train_t = time()
    res = GalacticOptim.solve(prob,ADAM(0.1);cb=cb,maxiters=maxiters)
    prob = remake(prob,u0=res.minimizer)
    res = GalacticOptim.solve(prob,ADAM(0.01);cb=cb,maxiters=maxiters)
    prob = remake(prob,u0=res.minimizer)
    res = GalacticOptim.solve(prob,ADAM(0.001);cb=cb,maxiters=maxiters)
    @info "Time to define model: " time()-train_t
    println("Finished training - saving model")
    @save "$model_path/neural_pde" chain
    #Creating Plot
    println("Creating Plot")
    plot_t = time()

    ts,xs,ys = [infimum(d.domain):0.1:supremum(d.domain) for d in domains]
    function plot_(res)
        # Animate
        anim = @animate for (i, t) in enumerate(0:0.05:t_max)
            @info "Animating frame $i..."
            u_real = reshape([analytic_sol_func(t,x,y) for x in xs for y in ys], (length(xs),length(ys)))
            u_predict = reshape([Array(phi([t, x, y], res.minimizer))[1] for x in xs for y in ys], length(xs), length(ys))
            u_error = abs.(u_predict .- u_real)
            title = @sprintf("predict t = %.3f", t)
            p1 = plot(xs, ys, u_predict,st=:surface, label="", title=title);
            title = @sprintf("real")
            p2 = plot(xs, ys, u_real,st=:surface, label="", title=title);
            title = @sprintf("error")
            p3 = plot(xs, ys, u_error, st=:contourf,label="", title=title);
            plot(p1,p2,p3);
        end
        gif(anim,"$output_path/plot.gif", fps=10);
    end
    println("Saving Plot")
    plot_(res);
    @info "Time to plot: " time()-plot_t
    println("Done")
    exit()

catch e
    trc = stacktrace(catch_backtrace())
    open(joinpath(output_path, "failure"), "w") do io
        print(io, "Exception during training: " * "$e" * "\n" * "$trc")
    end
    # A non-zero exit code causes the training job to be marked as Failed.
    exit()
    end
